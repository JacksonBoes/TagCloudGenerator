import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

/**
 * Program to read input from a given file and generate a well formatted html
 * file for a tag cloud made from the words of the input file.
 *
 * @author Jackson Boes
 */
public final class TagCloudGenerator {

    /**
     * No argument constructor--private to prevent instantiation.
     */
    private TagCloudGenerator() {
        // no code needed here
    }

    /**
     * Compare {@code Map.Entry<String, Integer>}s string keys in lexicographic
     * order, ignoring case.
     */
    private static class MapStringKey
            implements Comparator<Map.Entry<String, Integer>> {
        @Override
        public int compare(Map.Entry<String, Integer> p1,
                Map.Entry<String, Integer> p2) {
            int returnValue = 0;
            //if p1 and p2 keys are equal sort them by their values
            if (p1.getKey().equals(p2.getKey())) {
                returnValue = p1.getValue().compareTo(p2.getValue());
            } else {
                returnValue = p1.getKey().compareToIgnoreCase(p2.getKey());
            }
            return returnValue;
        }
    }

    /**
     * Compare {@code Map.Entry<String, Integer>}s Integer values in >= order.
     */
    private static class MapIntegerValue
            implements Comparator<Map.Entry<String, Integer>> {
        @Override
        public int compare(Map.Entry<String, Integer> p1,
                Map.Entry<String, Integer> p2) {
            int returnValue = 0;
            //if p1 and p2 values are equal sort them by their keys
            if (p1.getValue().equals(p2.getValue())) {
                returnValue = p1.getKey().compareToIgnoreCase(p2.getKey());
            } else {
                returnValue = p2.getValue().compareTo(p1.getValue());
            }
            return returnValue;
        }
    }

    /**
     * Outputs the "opening" tags of an html document. These are the tags that
     * will be generated: <html> <head> <title>Top [wordNum] Words in
     * [inputFile]</title>
     * <h1>Word Count in [inputFile]</h1> <link
     * href="http://web.cse.ohio-state.edu/software/2231" +
     * "/web-sw2/assignments/projects/tag-cloud-generator/" +
     * "data/tagcloud.css" rel = "stylesheet" type ="text/css">
     * <link href="tagcloud.css" rel="stylesheet" type="text/css">" </head>
     * <body data-new-gr-c-s-check-loaded="14.1103.0"data-gr-ext-installed>
     * <h1>Top [wordNum] words in [inputFile]</h1>
     * <hr>
     *
     * @param inputFile
     *            The name of the input file to be used in the output file
     * @param outFile
     *            the output stream
     * @param wordNum
     *            the number of words being included in the tag cloud
     * @updates outFile.content
     * @requires outFile.is_open
     * @ensures outFile.content = #outFile.content * [the opening tags for an
     *          html document]
     */
    public static void outputHeader(String inputFile, PrintWriter outFile,
            int wordNum) {
        assert outFile != null : "Violation of: outFile is not null";

        //print the opening tags
        outFile.println("<html>");
        outFile.println(" <head>");
        outFile.println("  <title>Top " + wordNum + " words in " + inputFile
                + "</title>");
        outFile.println(
                "  <link href=\"http://web.cse.ohio-state.edu/software/2231"
                        + "/web-sw2/assignments/projects/tag-cloud-generator/"
                        + "data/tagcloud.css\" rel = \"stylesheet\" type ="
                        + "\"text/css\">");
        outFile.println("  <link href=\"tagcloud.css\""
                + "rel=\"stylesheet\" type=\"text/css\">");
        outFile.println(" </head>");
        outFile.println(" <body data-new-gr-c-s-check-loaded=\"14.1103.0\""
                + "data-gr-ext-installed>");
        outFile.println(
                "  <h1>Top " + wordNum + " words in " + inputFile + "</h1>");
        outFile.println("  <hr>");
    }

    /**
     * Will output the "closing" tags of the html document. These are the tags
     * generated by the method: </body> </html>
     *
     * @param outFile
     *            the output stream
     * @updates outFile.content
     * @requires outFile.is_open
     * @ensures outFile.content = #outFile.content * [the closing tags for the
     *          html document]
     */
    public static void outputFooter(PrintWriter outFile) {
        assert outFile != null : "Violation of: outFile is not null";

        //output the closing tags for the html document
        outFile.println(" </body>");
        outFile.println("</html>");
    }

    /**
     * Read in the text in the input file and keep track of each unique word and
     * its occurrence count.
     *
     * @param inFile
     *            The input stream
     * @return the word -> its occurrence count map
     * @replaces countMap<String, Integer>
     * @requires <pre>
     * countMap<String, Integer> = {} and inFile is open
     * </pre>
     * @ensures countMap = [each unique word in the input file mapped to its
     *          occurrence count]
     */
    public static Map<String, Integer> getInput(BufferedReader inFile) {

        //string of all of the separator characters
        String separators = ",. -_/?!(){}[];:<>\\|+=*#$@%^'\"";

        //map to be returned by the method
        Map<String, Integer> countMap = new HashMap<>();

        try {
            //get the current line of the input file
            String currLine = inFile.readLine();
            //loop until the end of input file is reached
            while (currLine != null) {
                /*
                 * check each word on the current line and if it has been seen
                 * before increment its count in countMap and if not add it to
                 * countMap with a count of 1
                 */
                for (int i = 0; i < currLine.length(); i += 0) {
                    String currWord = nextWordOrSeparator(currLine, i,
                            separators);
                    i += currWord.length();
                    currWord = currWord.toLowerCase();
                    if (separators.indexOf(currWord.charAt(0)) < 0) {
                        if (countMap.containsKey(currWord)) {
                            int count = countMap.get(currWord);
                            countMap.replace(currWord, count + 1);
                        } else {
                            countMap.put(currWord, 1);
                        }
                    }
                }
                //get the next line of input
                currLine = inFile.readLine();
            }
        } catch (IOException e) {
            System.err.println("Error reading from input file");
            System.exit(0); //quit program if readLine fails
        }

        return countMap;
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code String} which contains the separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * if text[position, position + 1) is contained within the {@code String}
     * separators
     *      then nextWordOrSeparator will be the longest continuous substring
     *      of {@code text} starting at index {@code position} that can contain
     *      only characters also contained in {@code separators}
     * else
     *      nextWordOrSeparator will be the longest continuous substring of
     *      {@code text} starting at index {@code position} that can contains
     *      only characters not also contained in {@code separators}
     * </pre>
     */
    public static String nextWordOrSeparator(String text, int position,
            String separators) {
        //boolean for whether the string will be a separator string or a word
        boolean isSeparators = false;
        //boolean for whether the returnString has been found or not
        boolean foundString = false;

        //string to hold the return value
        String returnString = "";

        //currChar holds the current character from text being checked
        char currChar = text.charAt(position);
        /*
         * set isSeparators to true if the first char is a separator and false
         * otherwise, this will determine if the method returns a separator
         * string or a word
         */
        isSeparators = (separators.indexOf(currChar) >= 0);
        //add the first char to returnString
        returnString += currChar;

        /*
         * iterate through text starting at position plus one and if the
         * returnString is a separator string then add each separator to
         * returnString until a non separator is found when the loop will stop
         * and returnString will be returned, if returnString is a word then add
         * non separators until a separator is found
         */
        for (int i = (position + 1); (i < text.length()) && !foundString; i++) {
            currChar = text.charAt(i);
            if (isSeparators) {
                if (separators.indexOf(currChar) >= 0) {
                    returnString += currChar;
                } else {
                    foundString = true;
                }
            } else {
                if (separators.indexOf(currChar) < 0) {
                    returnString = returnString
                            .concat(Character.toString(currChar));
                } else {
                    foundString = true;
                }
            }
        }

        return returnString;
    }

    /**
     * Returns the [numWords] highest occurence count words in {@code countMap}
     * in a list sorted alphabetically, also populates {@code fontSizes} with
     * the words mapped to their respectve font sizes in the tag cloud according
     * to tagcloud.css.
     *
     * @param countMap
     *            The word -> its occurence count map
     * @param numWords
     *            The number of words to be included in the tag cloud
     * @param fontSizes
     *            The word -> its font size map
     * @replaces fontSizes
     * @clears countMap
     * @return a list with the top [numWords] words sorted alphabetically
     * @requires |fontSizes| = 0 and 0 <= numWords <= |countMap|
     * @ensures organizeData = [a list containing the [numWords] highest
     *          occurence count words from countMap in alphabetical order] and
     *          fontSizes = [a map of each word to the integer part of its font
     *          size as specified in tagcloud.css]
     *
     */
    public static List<Map.Entry<String, Integer>> organizeData(
            Map<String, Integer> countMap, int numWords,
            Map<String, Integer> fontSizes) {

        //create a comparator that will sort the pairs by highest value
        Comparator<Map.Entry<String, Integer>> countOrder = new MapIntegerValue();
        /*
         * create a list to hold the values to find the numWords values with the
         * highest occurnce counts
         */
        List<Map.Entry<String, Integer>> countSorter = new ArrayList<>();

        /*
         * put all of the pairs from countMap into countSorter, also clears
         * countMap
         */
        Iterator<Map.Entry<String, Integer>> it1 = countMap.entrySet()
                .iterator();
        while (it1.hasNext()) {
            Map.Entry<String, Integer> pair = it1.next();
            it1.remove();
            countSorter.add(pair);
        }
        //sort countSorter by highest values of the pairs
        Collections.sort(countSorter, countOrder);

        //create a comparator to sort pairs string keys alphabetically
        Comparator<Map.Entry<String, Integer>> wordOrder = new MapStringKey();
        /*
         * create a list to hold the top numWords entries and sort them
         * alphabetically
         */
        List<Map.Entry<String, Integer>> wordSorter = new ArrayList<>();

        //create an arrray to hold the max occurence count at 0 and the min at 1
        int[] max0min1 = new int[2];

        //create an iterator for countSorter
        Iterator<Map.Entry<String, Integer>> it2 = countSorter.iterator();
        if (numWords >= 2) {

            //get the highest word count from the first entry of countSorter
            Map.Entry<String, Integer> pair = it2.next();
            it2.remove();
            max0min1[0] = pair.getValue();
            //add the first entry of countSorter into wordSorter
            wordSorter.add(pair);

            //put the next numWords-2 pairs into wordSorter
            for (int i = 0; i < numWords - 2; i++) {
                Map.Entry<String, Integer> currPair = it2.next();
                it2.remove();
                wordSorter.add(currPair);
            }

            /*
             * get the lowest word count (of the words we will be using) from
             * the numWords entry of countSorter
             */
            pair = it2.next();
            it2.remove();
            max0min1[1] = pair.getValue();
            //add the numWords entry into wordSorter
            wordSorter.add(pair);
        } else if (numWords == 1) {
            /*
             * if there is only one word to be used then simply add it to
             * wordSorter
             */
            Map.Entry<String, Integer> pair = it2.next();
            it2.remove();
            wordSorter.add(pair);
            //pair.value() is both the max and min if there is only one word
            max0min1[0] = pair.getValue();
            max0min1[1] = pair.getValue();
        }

        //populate fontSizes with each word -> its font size
        getFontSizes(wordSorter, max0min1, fontSizes);

        //sort wordSorter alphabetically
        Collections.sort(wordSorter, wordOrder);

        return wordSorter;
    }

    /**
     * Populates {@code fontSizes} with the words to be used in the tag cloud
     * mapped to their font sizes. If all the words have the same occurence
     * count assign every word the average font size.
     *
     * @param wordList
     *            Sorted list of word -> its occurence count map pairs
     * @param max0min1
     *            An array of size 2 that holds the max word count at 0 and the
     *            min word count at 1
     * @param fontSizes
     *            The word -> its font size map
     * @replaces fontSize
     * @requires |fontSize| = 0
     * @ensures fontSize = [a map of each word to the integer part of its font
     *          size as specified in tagcloud.css]
     */
    public static void getFontSizes(List<Map.Entry<String, Integer>> wordList,
            int[] max0min1, Map<String, Integer> fontSizes) {
        final int largestFont = 48;
        final int smallestFont = 11;

        if (max0min1[0] != max0min1[1]) {
            /*
             * create a function for font: font = slope(count - minCount) +
             * smallestFont
             */
            double slope = (double) (largestFont - smallestFont)
                    / (max0min1[0] - max0min1[1]);

            /*
             * iterate through wordList and populate fontSizes with each word
             * mapped to its font size
             */
            for (int i = 0; i < wordList.size(); i++) {
                Map.Entry<String, Integer> pair = wordList.remove(0);
                double font = slope * (pair.getValue() - max0min1[1])
                        + smallestFont;
                int currFont = (int) Math.round(font);

                fontSizes.put(pair.getKey(), currFont);
                wordList.add(pair);
            }
        } else {
            for (int i = 0; i < wordList.size(); i++) {
                Map.Entry<String, Integer> pair = wordList.remove(0);
                /*
                 * use an average of the two font sizes as the default if all
                 * the words have the same occurence count
                 */
                fontSizes.put(pair.getKey(), (largestFont - smallestFont) / 2);
                wordList.add(pair);
            }
        }
    }

    /**
     * Removes every entry from {@code sortedWords} and adds it to the tag cloud
     * output in the html output file.
     *
     * @param outFile
     *            The output stream to the output file
     * @param sortedWords
     *            The words to be included in the tag cloud in alphabetical
     *            order
     * @param fontSizes
     *            The word -> its font size map
     * @param numWords
     *            The number of words to be included in the tag cloud
     * @updates sortedWords
     * @requires outFile.is_open
     * @ensures outFile.content = #outFile.content * [the html for the word
     *          cloud with all of the words in {@code sortedWords}]
     */
    public static void generateTagCloud(PrintWriter outFile,
            List<Map.Entry<String, Integer>> sortedWords,
            Map<String, Integer> fontSizes, int numWords) {
        outFile.println("  <div class=\"cdiv\">");
        outFile.println("   <p class=\"cbox\">");
        /*
         * for every word that is to be included in the tag cloud remove it from
         * sortedWords and get its font size from fontSizes
         */
        for (int i = 0; i < numWords; i++) {
            Map.Entry<String, Integer> currWord = sortedWords.remove(0);
            outFile.println("    <span style=\"cursor:default\" class=\"f"
                    + fontSizes.get(currWord.getKey()) + "\" title=\"count: "
                    + currWord.getValue() + "\">" + currWord.getKey()
                    + "</span>");
        }
        outFile.println("   </p>");
        outFile.println("  </div>");
    }

    /**
     * Method to determine whether the given string {@code str} can be parsed
     * into an int.
     *
     * @param str
     *            The string to check
     * @return true if str is an int, false otherwise
     * @ensures isInt = [true if str can be parsed into an int and false
     *          otherwise]
     */
    public static boolean isInt(String str) {
        boolean isInt = true;
        for (int i = 0; i < str.length(); i++) {
            if (!Character.isDigit(str.charAt(i))) {
                isInt = false;
            }
        }
        if (str.length() == 0) {
            isInt = false;
        }
        return isInt;
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        //get the input and output file names
        System.out.print("Enter an input file: ");
        String inputFile = input.nextLine();
        //boolean for if the input file has been successfully opened
        boolean inFileOpen = false;
        //open the input file
        /*
         * inFile is initialized as null but this will not raise issues since
         * the program connot move on until the try block completes successfully
         * which will give inFile a non null value
         */
        BufferedReader inFile = null;
        while (!inFileOpen) {
            try {
                inFile = new BufferedReader(new FileReader(inputFile));
                inFileOpen = true;
            } catch (FileNotFoundException e) {
                System.err.println("Error opening input file");
                System.out.print("Enter another input file: ");
                inputFile = input.nextLine();
            }
        }

        //get the output file name
        System.out.print("Enter an output file: ");
        String outputFile = input.nextLine();
        //boolean for if the output file has been successfully opened
        boolean outFileOpen = false;
        //open the output file
        /*
         * outFile is initialized as null but this will not raise issues since
         * the program connot move on until the try block completes successfully
         * which will give outFile a non null value
         */
        PrintWriter outFile = null;
        while (!outFileOpen) {
            try {
                outFile = new PrintWriter(
                        new BufferedWriter(new FileWriter(outputFile)));
                outFileOpen = true;
            } catch (IOException e) {
                System.err.println("Error opening output file");
                System.out.print("Enter another output file: ");
                outputFile = input.nextLine();
            }
        }

        /*
         * create a map<String, Integer> to hold each unique word in the input
         * file and its occurrence count
         */
        Map<String, Integer> countMap = getInput(inFile);

        System.out.print(
                "Enter the number of words to be included in the tag cloud: ");
        String userNum = input.nextLine();
        //continually ask for a number of words until a valid number is entered
        while (!isInt(userNum) || Integer.parseInt(userNum) < 0
                || Integer.parseInt(userNum) > countMap.size()) {
            System.out.println(
                    "You must enter a non-negative number that is less "
                            + "than the number of words in your file");
            System.out.print(
                    "Enter the number of words to be included in the tag cloud: ");
            userNum = input.nextLine();
        }
        int numWords = Integer.parseInt(userNum);

        //create map for word -> its font size
        Map<String, Integer> fontSizes = new HashMap<>();

        /*
         * organize the data from countMap to get a list with the words sorted
         * in alphabetical order and a map of the words and their font sizes for
         * the tag cloud
         */
        List<Map.Entry<String, Integer>> wordSorter = organizeData(countMap,
                numWords, fontSizes);

        //output the header of the output file
        outputHeader(inputFile, outFile, numWords);

        //output the html for the tag cloud to the output file
        generateTagCloud(outFile, wordSorter, fontSizes, numWords);

        //output the footer of the output file
        outputFooter(outFile);

        /*
         * Close input and output streams
         */
        outFile.close();
        input.close();
        try {
            inFile.close();
        } catch (IOException e) {
            System.err.println("Error closing input file");
            //let program end after a catch
        }
    }

}
